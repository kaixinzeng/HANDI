#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
plot_flag_styled_upsample.py

4D (or dim-D) ODE overlay plotter:
- Correct variable mapping: x(1)->x1, x(2)->x2, ...
- True dim-D integration via solve_ivp
- Plot style aligned with plot_nolegend_new_modified_v2.py
- High-resolution truth is GENERATED by CubicSpline upsampling from training truth:
    dashed black line = upsampled truth
    white-faced black-edged scatter = original training points (downsample optional)
- Truncation bounds:
    bounds are computed from HANDI prediction's per-dim min/max, scaled by --bounds-scale.
    MODIFIED: Integration does NOT stop globally if one dimension leaves bounds.
    Instead, integration continues. Values outside bounds are masked to NaN individually
    post-integration for plotting clarity, allowing stable dimensions to be shown fully.

Example:
python plot_flag_styled_upsample.py \
  --truth-npy dataV1/4d/4d_ds3.npy --dt 0.1 --traj-idx 0 --tmax 15 --dim 4 \
  --handi-eq true_systemV1/true_system/flag/HANDI/dt0.1_equations.txt \
  --pse-eq   true_systemV1/true_system/flag/PSE/dt0.1_equations.txt \
  --sindy-eq true_systemV1/true_system/flag/SINDy/dt0.1_equations.txt \
  --sr3-eq   true_systemV1/true_system/flag/SR3/dt0.1_equations.txt \
  --out-dir plots_4d --plot-dims 2 --save-format svg --no-legend \
  --bounds-from HANDI --bounds-scale 3.0
"""

import os
import re
import argparse
from dataclasses import dataclass
from typing import Tuple, Dict, Optional, List

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.integrate import solve_ivp
from scipy.interpolate import CubicSpline

import sympy as sp
from sympy.parsing.sympy_parser import (
    parse_expr,
    standard_transformations,
    implicit_multiplication_application,
    convert_xor,
)

# -----------------------------
# Style (ported/aligned)
# -----------------------------
plt.rcParams["font.family"] = "DejaVu Sans"
plt.rcParams["axes.unicode_minus"] = False


@dataclass
class Style:
    fig_w: float = 8.96
    fig_h_unit: float = 3.05  # height per subplot (stacked)

    method_lw: float = 4.0
    method_alpha: float = 0.95
    smooth_dense_factor: int = 12

    truth_color: str = "#000000"
    truth_lw: float = 2.6
    truth_alpha: float = 1.0
    truth_dash: Tuple[int, int] = (1, 1)
    truth_scatter_s: float = 55.0
    truth_scatter_edge_lw: float = 1.8

    tick_fontsize: int = 46
    spine_width: float = 3.0
    spine_color: str = "black"
    show_spines: Tuple[str, ...] = ("left", "bottom")

    colors: Dict[str, str] = None


STYLE = Style(colors={
    "PSE":   "#D8A0A7",
    "HANDI": "#50AAD8",
    "SINDy": "#d06569",
    "SR3":   "#C9A1CB",
})


def _pretty_1dec_formatter(x, pos=None) -> str:
    if not np.isfinite(x):
        return ""
    if abs(x - round(x)) < 1e-8:
        return f"{round(x):>5.1f}"
    else:
        return f"{x:>5.1f}"


def _parse_float_list(s: Optional[str]) -> Optional[List[float]]:
    """Parse comma-separated floats; empty/None -> None."""
    if s is None:
        return None
    s = str(s).strip()
    if s == "":
        return None
    parts = [p.strip() for p in s.split(",") if p.strip() != ""]
    if len(parts) == 0:
        return None
    return [float(p) for p in parts]


def _compute_truth_ylims(truth: np.ndarray, plot_dims: int, scale: float) -> List[Tuple[float, float]]:
    """Per-dimension y-lims from truth, expanded by `scale` around the center."""
    truth = np.asarray(truth, float)
    ylims: List[Tuple[float, float]] = []
    for i in range(int(plot_dims)):
        yi = truth[:, i]
        mask = np.isfinite(yi)
        if not np.any(mask):
            ylims.append((np.nan, np.nan))
            continue
        lo = float(np.min(yi[mask]))
        hi = float(np.max(yi[mask]))
        span = max(hi - lo, 1e-6)
        c = 0.5 * (hi + lo)
        half = 0.5 * span * float(scale)
        ylims.append((c - half, c + half))
    return ylims


def apply_spines(ax) -> None:
    for side in ("left", "right", "top", "bottom"):
        ax.spines[side].set_visible(False)
    for side in STYLE.show_spines:
        ax.spines[side].set_visible(True)
        ax.spines[side].set_linewidth(STYLE.spine_width)
        ax.spines[side].set_color(STYLE.spine_color)
    ax.yaxis.set_ticks_position("left")
    ax.xaxis.set_ticks_position("bottom")


def apply_ticks_adaptive(ax, xspan: float) -> None:
    """
    x: adaptive 3 or 4 ticks
    y: 3 ticks
    """
    nbins_x = 3 if xspan <= 1.2 else 4
    ax.xaxis.set_major_locator(ticker.MaxNLocator(nbins=nbins_x, steps=[1, 2, 2.5, 5, 10], min_n_ticks=2))
    ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=3, steps=[1, 2, 2.5, 5, 10], min_n_ticks=2))

    fmt = ticker.FuncFormatter(_pretty_1dec_formatter)
    ax.xaxis.set_major_formatter(fmt)
    ax.yaxis.set_major_formatter(fmt)

    ax.tick_params(
        labelsize=STYLE.tick_fontsize,
        width=STYLE.spine_width,
        direction="out",
        top=False,
        right=False,
    )


# -----------------------------
# helpers
# -----------------------------
def ensure_dir(p: str):
    os.makedirs(p, exist_ok=True)


def to_time_grid(T: int, dt: float):
    return np.arange(T, dtype=float) * float(dt)


def mse_euclid(true_traj: np.ndarray, pred_traj: np.ndarray) -> float:
    """true/pred: (T, d). MSE = mean(||pred-true||^2). Ignores NaNs in pred."""
    true = np.asarray(true_traj, float)
    pred = np.asarray(pred_traj, float)
    mask = np.isfinite(pred).all(axis=1)
    if not np.any(mask):
        return float("inf")
    d = pred[mask] - true[mask]
    return float(np.mean(np.sum(d * d, axis=1)))


def compress_spaces(s: str) -> str:
    return " ".join(s.replace("\r", "\n").split())


def map_x_paren_to_xi(expr_str: str) -> str:
    """x(1)->x1, x(2)->x2, ... (NO shift)"""
    return re.sub(r"x\s*\(\s*(\d+)\s*\)", lambda m: f"x{int(m.group(1))}", expr_str)


def map_xi_to_x_paren(expr_str: str) -> str:
    """x1->x(1), x2->x(2) ... (word-boundary safe)"""
    return re.sub(r"\bx(\d+)\b", lambda m: f"x({int(m.group(1))})", expr_str)


def extract_rhs_blocks(text: str, dim: int):
    """
    Extract RHS for each k=1..dim.
    Captures from '=' to next 'dx(' or EOF.
    """
    rhs_list = [None] * dim
    for k in range(1, dim + 1):
        m = re.search(
            rf"dx\s*\(\s*{k}\s*\)\s*/\s*dt\s*=\s*(.*?)(?=\n\s*dx\s*\(|\Z)",
            text,
            flags=re.DOTALL,
        )
        if m is None:
            # fallback dxk/dt
            m2 = re.search(
                rf"dx\s*{k}\s*/\s*dt\s*=\s*(.*?)(?=\n\s*dx\s*\d\s*/\s*dt|\Z)",
                text,
                flags=re.DOTALL,
            )
            rhs_list[k - 1] = compress_spaces(m2.group(1)) if m2 else None
        else:
            rhs_list[k - 1] = compress_spaces(m.group(1))
    return rhs_list


_TRANS = standard_transformations + (implicit_multiplication_application, convert_xor)


def parse_equations_file(eq_path: str, dim: int):
    """
    Return:
      exprs: list[sympy.Expr] length dim
      unified_lines: list[str] each "dx(k)/dt = ..." in x(1..dim) form
    """
    with open(eq_path, "r", encoding="utf-8") as f:
        text = f.read()

    rhs_blocks = extract_rhs_blocks(text, dim)

    xs = sp.symbols(" ".join([f"x{i}" for i in range(1, dim + 1)]))
    locals_map = {f"x{i}": xs[i - 1] for i in range(1, dim + 1)}
    locals_map.update({"sin": sp.sin, "cos": sp.cos, "exp": sp.exp, "log": sp.log, "sqrt": sp.sqrt})

    exprs = []
    unified_lines = []

    for k in range(1, dim + 1):
        rhs = rhs_blocks[k - 1]
        if rhs is None:
            e = sp.Integer(0)
            exprs.append(e)
            unified_lines.append(f"dx({k})/dt = 0")
            continue

        rhs = rhs.replace("^", "**")
        rhs = map_x_paren_to_xi(rhs)
        rhs = compress_spaces(rhs)

        try:
            e = parse_expr(rhs, local_dict=locals_map, transformations=_TRANS, evaluate=True)
        except Exception as ex:
            raise RuntimeError(
                f"[PARSE ERROR] {eq_path} dim {k} failed.\n"
                f"RHS(after map) = {rhs}\n"
                f"Error: {ex}"
            )

        exprs.append(sp.simplify(e))
        unified_lines.append(f"dx({k})/dt = {map_xi_to_x_paren(str(exprs[-1]))}")

    # diagnostics
    print(f"[EQ PARSE] {os.path.basename(eq_path)} free_symbols:")
    for k in range(dim):
        syms = sorted([str(s) for s in exprs[k].free_symbols])
        print(f"  dim{k + 1}: {syms}")

    return exprs, unified_lines


def build_rhs_func(exprs, dim: int):
    xs = sp.symbols(" ".join([f"x{i}" for i in range(1, dim + 1)]))
    f_lambdas = [sp.lambdify(xs, expr, "numpy") for expr in exprs]

    def rhs(t, y):
        x = tuple(float(v) for v in y)
        out = np.empty(dim, dtype=float)
        for i, fi in enumerate(f_lambdas):
            try:
                out[i] = float(fi(*x))
            except Exception:
                out[i] = np.nan
        return out

    return rhs


def compute_bounds_from_pred(pred: np.ndarray, scale: float, min_abs: float = 0.0):
    """
    Robust bounds computation based on center and span.
    """
    P = np.asarray(pred, float)
    mask = np.isfinite(P).all(axis=1)
    if not np.any(mask):
        return None, None
    A = P[mask]

    low = np.nanmin(A, axis=0)
    high = np.nanmax(A, axis=0)

    span = high - low
    center = (high + low) / 2.0

    span = np.maximum(span, 1e-6)
    half_new_span = (span * scale) / 2.0

    bounds_low = center - half_new_span
    bounds_high = center + half_new_span

    if min_abs > 0:
        bounds_low = np.minimum(bounds_low, -abs(min_abs))
        bounds_high = np.maximum(bounds_high, abs(min_abs))

    return bounds_low, bounds_high


def integrate_ode(
        rhs, x0, t_eval,
        method="RK45", rtol=1e-7, atol=1e-9, max_step=None,
        bounds_low: Optional[np.ndarray] = None,
        bounds_high: Optional[np.ndarray] = None,
):
    """
    Integrates the ODE.

    MODIFIED:
    - Does NOT stop integration if bounds are exceeded (no terminal events).
    - Instead, it integrates as far as possible (up to NaNs/Inf or t_eval end).
    - If bounds are provided, the returned Y is masked (values outside bounds become NaN)
      so that plotting is clean, but other dimensions are preserved if they are within bounds.
    """
    t_span = (float(t_eval[0]), float(t_eval[-1]))
    y0 = np.asarray(x0, float)

    # Initial condition check (soft warning, or could return NaNs if strictly enforced)
    if bounds_low is not None and bounds_high is not None:
        low = np.asarray(bounds_low, float)
        high = np.asarray(bounds_high, float)
        if np.any(y0 < low) or np.any(y0 > high):
            print("[WARN] Initial condition outside bounds. Integration proceeding but may be masked immediately.")

    # NO events passed -> Integrate fully
    sol = solve_ivp(
        rhs,
        t_span=t_span,
        y0=y0,
        t_eval=t_eval,
        method=method,
        rtol=rtol,
        atol=atol,
        max_step=max_step,
        # events=None  <-- Removed terminal events
    )

    if sol.y is None or sol.y.size == 0:
        Y = np.full((len(t_eval), len(y0)), np.nan, dtype=float)
        return sol, Y

    Y_part = sol.y.T
    Y = np.full((len(t_eval), Y_part.shape[1]), np.nan, dtype=float)
    n = min(len(t_eval), Y_part.shape[0])
    Y[:n] = Y_part[:n]

    # Post-processing mask: if value is outside bounds, make it NaN
    # This hides the divergence without stopping the other dimensions
    if bounds_low is not None and bounds_high is not None:
        # Broadcasting comparison
        # Y is (T, D), low/high are (D,)
        mask_out = (Y < bounds_low) | (Y > bounds_high)
        # Apply NaN mask
        if np.any(mask_out):
            Y[mask_out] = np.nan

    return sol, Y


# -----------------------------
# plot helpers
# -----------------------------
def upsample_series(t: np.ndarray, y: np.ndarray, dense_factor: int):
    """
    High-res truth from training truth via CubicSpline (finite prefix).
    Returns (t_dense, y_dense) or (None, None).
    """
    t = np.asarray(t, float)
    y = np.asarray(y, float)
    mask = np.isfinite(y)
    if not np.any(mask):
        return None, None
    last = np.where(mask)[0][-1]
    t0, y0 = t[:last + 1], y[:last + 1]

    if len(t0) < 4 or dense_factor <= 1:
        return t0, y0

    t_dense = np.linspace(t0[0], t0[-1], (len(t0) - 1) * dense_factor + 1)
    try:
        cs = CubicSpline(t0, y0)
        y_dense = cs(t_dense)
    except Exception:
        y_dense = np.interp(t_dense, t0, y0)
    return t_dense, y_dense


def plot_smooth_method(ax, t: np.ndarray, y: np.ndarray, *, color: str):
    """Method curve: smooth & thick; finite prefix only."""
    t = np.asarray(t, float)
    y = np.asarray(y, float)
    mask = np.isfinite(y)
    if not np.any(mask):
        return

    # We might have gaps due to masking (e.g. divergence).
    # CubicSpline over gaps is risky. We plot non-NaN segments.
    # Simple approach: Plot as is. Matplotlib handles NaNs by breaking line.

    # However, if we want smoothing, we need continuous data.
    # If the user wants upsampled smoothing for predictions, it works best on continuous blocks.
    # For now, we will upsample the *valid prefix* or just plot raw if gaps exist.

    # If there are NaNs in the middle, `last` is not sufficient.
    # For robustness in "divergence masking" scenario, we just plot raw if there are gaps
    # OR we treat the longest prefix.
    # Let's stick to the original logic: find last valid index.
    # WARNING: If we masked out the *middle*, the original logic might act weird.
    # But typically divergence happens at the end.

    last = np.where(mask)[0][-1]
    # Check if there are internal NaNs
    if np.any(np.isnan(y[:last + 1])):
        # Internal NaNs exist (e.g. one specific point went out of bounds?).
        # Fallback to direct plotting to handle gaps correctly.
        ax.plot(t[:last + 1], y[:last + 1], color=color, lw=STYLE.method_lw, alpha=STYLE.method_alpha,
                solid_capstyle="round", zorder=2)
        return

    t0, y0 = t[:last + 1], y[:last + 1]

    if len(t0) < 4 or STYLE.smooth_dense_factor <= 1:
        ax.plot(t0, y0, color=color, lw=STYLE.method_lw, alpha=STYLE.method_alpha,
                solid_capstyle="round", zorder=2)
        return

    t_dense = np.linspace(t0[0], t0[-1], (len(t0) - 1) * STYLE.smooth_dense_factor + 1)
    try:
        cs = CubicSpline(t0, y0)
        y_dense = cs(t_dense)
    except Exception:
        y_dense = np.interp(t_dense, t0, y0)

    ax.plot(t_dense, y_dense, color=color, lw=STYLE.method_lw, alpha=STYLE.method_alpha,
            solid_capstyle="round", zorder=2)


def plot_truth_upsampled_plus_scatter(
        ax,
        t_train: np.ndarray,
        y_train: np.ndarray,
        *,
        dense_factor: int,
        marker_step: int,
):
    # dashed truth from upsample
    t_hi, y_hi = upsample_series(t_train, y_train, dense_factor=dense_factor)
    if t_hi is not None and y_hi is not None:
        ax.plot(
            t_hi, y_hi,
            color=STYLE.truth_color,
            linewidth=STYLE.truth_lw,
            alpha=STYLE.truth_alpha,
            linestyle=(0, STYLE.truth_dash),
            zorder=6
        )

    # scatter from training points (optionally downsample)
    step = int(marker_step) if int(marker_step) >= 1 else 1
    tt = np.asarray(t_train, float)[::step]
    yy = np.asarray(y_train, float)[::step]
    mask = np.isfinite(yy)
    if np.any(mask):
        last = np.where(mask)[0][-1]
        ax.scatter(
            tt[:last + 1], yy[:last + 1],
            s=STYLE.truth_scatter_s,
            facecolors="#FFFFFF",
            edgecolors=STYLE.truth_color,
            linewidths=STYLE.truth_scatter_edge_lw,
            zorder=7
        )


def maybe_add_legend(ax):
    """Add legend only if there are labeled artists."""
    handles, labels = ax.get_legend_handles_labels()
    good = [(h, l) for (h, l) in zip(handles, labels) if l and not l.startswith("_")]
    if len(good) == 0:
        return
    h2, l2 = zip(*good)
    ax.legend(h2, l2, loc="best", frameon=False)


# -----------------------------
# main
# -----------------------------
def main():
    ap = argparse.ArgumentParser()

    ap.add_argument("--truth-npy", type=str, default="dataV1/4d/4d_ds6.npy", help="(N,T,4) truth npy")
    ap.add_argument("--dt", type=float, default=0.2)
    ap.add_argument("--traj-idx", type=int, default=0)
    ap.add_argument("--tmax", type=float, default=10, help="truncate to t<=tmax (in same unit as dt)")
    ap.add_argument("--dim", type=int, default=4)

    # equation files
    ap.add_argument("--handi-eq", type=str,
                    default="true_systemV1/true_systemV1/true_system/flag/HANDI/dt0.2_equations.txt")
    ap.add_argument("--pse-eq", type=str,
                    default="true_systemV1/true_systemV1/true_system/flag/PSE/dt0.2_equations.txt")
    ap.add_argument("--sindy-eq", type=str,
                    default="true_systemV1/true_systemV1/true_system/flag/SINDy/dt0.2_equations.txt")
    ap.add_argument("--sr3-eq", type=str,
                    default="true_systemV1/true_systemV1/true_system/flag/SR3/dt0.2_equations.txt")

    ap.add_argument("--out-dir", type=str, default="plots_flag_styled")

    # integration controls
    ap.add_argument("--ivp-method", type=str, default="RK45")
    ap.add_argument("--rtol", type=float, default=1e-7)
    ap.add_argument("--atol", type=float, default=1e-9)
    ap.add_argument("--max-step", type=float, default=None, help="recommended = dt (or dt/2)")

    # truncation bounds
    ap.add_argument("--bounds-from", type=str, default="HANDI",
                    help="which method to compute bounds from (default HANDI)")
    ap.add_argument("--bounds-scale", type=float, default=3.0,
                    help="bounds = [min,max] of bounds-from pred per-dim times this scale")
    ap.add_argument("--bounds-min-abs", type=float, default=2.0,
                    help="optional: enforce at least [-min_abs, +min_abs]")

    # plotting controls
    ap.add_argument("--plot-dims", type=int, default=2, help="2 or dim")
    ap.add_argument("--truth-upsample-factor", type=int, default=12)
    ap.add_argument("--marker-step", type=int, default=3)
    ap.add_argument("--save-format", type=str, default="svg", choices=["png", "svg"])
    ap.add_argument("--no-legend", default=True)

    # y-lim controls (minimal-intrusive; does NOT touch ticks/spines/line styles)
    ap.add_argument(
        "--ylim-mode",
        type=str,
        default="truth",
        choices=["truth", "manual", "none"],
        help=(
            "truth: per-dim ylim from TRUTH (default, recommended for cross-dt consistency); "
            "manual: use provided mins/maxs; none: do not set ylim"
        ),
    )
    ap.add_argument(
        "--ylim-scale",
        type=float,
        default=1.5,
        help="Only for --ylim-mode truth: expand truth span by this factor (e.g., 1.05).",
    )

    # Manual y-lims (choose ONE style):
    # 1) list form (comma-separated): --ymin "a,b" --ymax "c,d"
    ap.add_argument("--ymin", type=str, default=None, help="Comma-separated y-min list for manual ylim.")
    ap.add_argument("--ymax", type=str, default=None, help="Comma-separated y-max list for manual ylim.")

    # 2) per-dim form (works up to 4D; ignored if not provided)
    for k in range(1, 5):
        ap.add_argument(f"--y{k}-min", type=float, default=None)
        ap.add_argument(f"--y{k}-max", type=float, default=None)

    # optional style overrides
    ap.add_argument("--method-lw", type=float, default=None)
    ap.add_argument("--truth-lw", type=float, default=None)
    ap.add_argument("--dash-on", type=int, default=None)
    ap.add_argument("--dash-off", type=int, default=None)
    ap.add_argument("--tick-fontsize", type=int, default=None)
    ap.add_argument("--spine-width", type=float, default=None)
    ap.add_argument("--smooth-factor", type=int, default=None)
    ap.add_argument("--hspace", type=float, default=0.5,
                    help="Vertical space between subplots (figure-relative). Increase to separate panels.")


    args = ap.parse_args()

    # apply style overrides
    if args.method_lw is not None:
        STYLE.method_lw = float(args.method_lw)
    if args.truth_lw is not None:
        STYLE.truth_lw = float(args.truth_lw)
    if args.dash_on is not None and args.dash_off is not None:
        STYLE.truth_dash = (int(args.dash_on), int(args.dash_off))
    if args.tick_fontsize is not None:
        STYLE.tick_fontsize = int(args.tick_fontsize)
    if args.spine_width is not None:
        STYLE.spine_width = float(args.spine_width)
    if args.smooth_factor is not None:
        STYLE.smooth_dense_factor = int(args.smooth_factor)

    ensure_dir(args.out_dir)

    # ---- load truth ----
    data = np.load(args.truth_npy, allow_pickle=True).astype(float)
    if data.ndim != 3 or data.shape[-1] != args.dim:
        raise ValueError(f"Expected shape (N,T,{args.dim}), got {data.shape}")

    N, T, d = data.shape
    if not (0 <= args.traj_idx < N):
        raise ValueError(f"traj-idx out of range: {args.traj_idx}, N={N}")

    # truncate by tmax
    if args.tmax is not None:
        T_use = int(np.floor(float(args.tmax) / float(args.dt))) + 1
        T_use = max(2, min(T, T_use))
    else:
        T_use = T

    truth = data[args.traj_idx, :T_use, :]  # (T_use, d)
    t_eval = to_time_grid(T_use, args.dt)

    # ---- methods ----
    methods: List[Tuple[str, str]] = []
    if args.handi_eq.strip():
        methods.append(("HANDI", args.handi_eq))
    if args.pse_eq.strip():
        methods.append(("PSE", args.pse_eq))
    if args.sindy_eq.strip():
        methods.append(("SINDy", args.sindy_eq))
    if args.sr3_eq.strip():
        methods.append(("SR3", args.sr3_eq))

    if len(methods) == 0:
        raise ValueError("No equation files provided. Use --handi-eq/--pse-eq/...")

    eq_path_map = {n: p for (n, p) in methods}

    # ---- save unified equations ----
    unified_path = os.path.join(args.out_dir, f"unified_equations_{d}d.txt")
    with open(unified_path, "w", encoding="utf-8") as f_out:
        f_out.write(f"# unified equations (dim={d})\n")
        for name, eq_path in methods:
            exprs, unified_lines = parse_equations_file(eq_path, d)
            f_out.write(f"\n[{name}] {eq_path}\n")
            for line in unified_lines:
                f_out.write(line + "\n")
            dx1_symbols = sorted([str(s) for s in exprs[0].free_symbols])
            if "x1" not in dx1_symbols:
                print(f"[WARN] {name}: dx(1)/dt free_symbols has NO x1. Check mapping/file content!")

    print(f"[OK] wrote unified equations to: {unified_path}")

    # ---- Phase A: compute bounds from bounds-from method prediction ----
    bounds_low = None
    bounds_high = None

    bounds_from = args.bounds_from.strip() if args.bounds_from else ""
    if bounds_from:
        if bounds_from not in eq_path_map:
            raise ValueError(f"--bounds-from {bounds_from} not in methods {list(eq_path_map.keys())}")

        print(f"\n[BOUNDS] computing bounds from {bounds_from} (no bounds applied during this calc)")
        exprs_b, _ = parse_equations_file(eq_path_map[bounds_from], d)
        rhs_b = build_rhs_func(exprs_b, d)
        max_step_b = args.max_step if args.max_step is not None else args.dt

        # For bounds computation, we also don't want to kill it early, just get the data
        sol_b, Y_b = integrate_ode(
            rhs_b, truth[0, :], t_eval,
            method=args.ivp_method,
            rtol=args.rtol, atol=args.atol,
            max_step=max_step_b,
            bounds_low=None, bounds_high=None,
        )

        bounds_low, bounds_high = compute_bounds_from_pred(
            Y_b, scale=float(args.bounds_scale), min_abs=float(args.bounds_min_abs)
        )
        if bounds_low is None:
            print("[BOUNDS][WARN] bounds-from prediction has no finite points; fallback to NO bounds.")
        else:
            print("[BOUNDS] low =", bounds_low)
            print("[BOUNDS] high=", bounds_high)

    # ---- Phase B: integrate all methods WITH masking (not termination) ----
    preds: Dict[str, np.ndarray] = {}
    x0 = truth[0, :]

    for name, eq_path in methods:
        print(f"\n[RUN] {name} integrate {d}D from x0={x0}")
        print(f"       (masking outside bounds: {bounds_low is not None})")
        exprs, _ = parse_equations_file(eq_path, d)
        rhs = build_rhs_func(exprs, d)
        max_step = args.max_step if args.max_step is not None else args.dt

        # IMPORTANT: We pass bounds to integrate_ode, but logic now MASKS rather than STOPS
        sol, Y = integrate_ode(
            rhs, x0, t_eval,
            method=args.ivp_method,
            rtol=args.rtol, atol=args.atol,
            max_step=max_step,
            bounds_low=bounds_low, bounds_high=bounds_high,
        )

        finite_mask = np.isfinite(Y).all(axis=1)
        last_ok = np.where(finite_mask)[0]
        if len(last_ok) == 0:
            print(f"[DIAG] {name}: no finite points (all masked or failed). success={getattr(sol, 'success', False)}")
        else:
            last_ok = int(last_ok[-1])
            print(f"[DIAG] {name}: valid points={last_ok + 1}/{len(t_eval)} (masked tail or NaNs).")

        preds[name] = Y
        m = mse_euclid(truth, Y)
        print(f"[METRIC] {name}: MSE({d}D) = {m:.6e}")

    # ---- Plotting ----
    plot_dims = int(args.plot_dims)
    if plot_dims == 4 and d != 4:
        plot_dims = d
    if plot_dims not in (2, d) and plot_dims != 1:
        raise ValueError(f"--plot-dims must be 1, 2, or {d}")
    plot_dims = min(plot_dims, d)

    fig_h = STYLE.fig_h_unit * plot_dims
    fig, axes = plt.subplots(plot_dims, 1, figsize=(STYLE.fig_w, fig_h), sharex=True)
    if plot_dims == 1:
        axes = [axes]

    fig.subplots_adjust(hspace=float(args.hspace))

    # xlim padding: INCREASED padding for better whitespace
    t_end = float(t_eval[-1])
    # Changed from 0.02 to 0.10 (10%) + a small base margin
    right_pad = 0.10 * max(t_end, 1e-12) + 0.1
    x_right = t_end + right_pad
    xspan = x_right - 0.0

    # ---- y-lims (per subplot/dimension) ----
    # Goal: use TRUTH to define a consistent ylim for each y-dimension,
    #       so that different dt runs are comparable.
    ylims: List[Tuple[float, float]] = [(np.nan, np.nan)] * plot_dims
    if args.ylim_mode == "truth":
        ylims = _compute_truth_ylims(truth, plot_dims=plot_dims, scale=float(args.ylim_scale))
    elif args.ylim_mode == "manual":
        ymin_list = _parse_float_list(args.ymin)
        ymax_list = _parse_float_list(args.ymax)

        if ymin_list is not None or ymax_list is not None:
            if ymin_list is None or ymax_list is None:
                raise ValueError("For manual ylim with list form, provide BOTH --ymin and --ymax.")
            if len(ymin_list) < plot_dims or len(ymax_list) < plot_dims:
                raise ValueError(f"Manual list ylims require >= {plot_dims} values in --ymin/--ymax.")
            ylims = [(float(ymin_list[i]), float(ymax_list[i])) for i in range(plot_dims)]
        else:
            # per-dim flags --y1-min/--y1-max ... (up to 4 dims)
            ylims2: List[Tuple[float, float]] = []
            for i in range(plot_dims):
                k = i + 1
                vmin = getattr(args, f"y{k}_min")
                vmax = getattr(args, f"y{k}_max")
                if vmin is None or vmax is None:
                    raise ValueError(
                        f"Manual ylims missing for dim {k}. Provide --ymin/--ymax list OR --y{k}-min/--y{k}-max."
                    )
                ylims2.append((float(vmin), float(vmax)))
            ylims = ylims2
    elif args.ylim_mode == "none":
        pass
    else:
        raise ValueError(f"Unknown --ylim-mode: {args.ylim_mode}")

    for i in range(plot_dims):
        ax = axes[i]

        # method curves first (under truth)
        for name, _ in methods:
            color = STYLE.colors.get(name, "black")
            # give label only if legend requested
            if not args.no_legend:
                ax.plot([], [], color=color, lw=STYLE.method_lw, label=name)  # dummy label handle
            plot_smooth_method(ax, t_eval, preds[name][:, i], color=color)

        # truth on top
        plot_truth_upsampled_plus_scatter(
            ax, t_eval, truth[:, i],
            dense_factor=int(args.truth_upsample_factor),
            marker_step=int(args.marker_step),
        )

        ax.margins(x=0)
        ax.set_xlim(0.0, x_right)
        # Set per-dim ylim if requested
        if args.ylim_mode != "none":
            ylo, yhi = ylims[i]
            if np.isfinite(ylo) and np.isfinite(yhi) and (yhi > ylo):
                ax.set_ylim(ylo, yhi)
        apply_ticks_adaptive(ax, xspan=xspan)
        apply_spines(ax)
        ax.grid(False)

    if not args.no_legend:
        maybe_add_legend(axes[0])

    out_fig = os.path.join(args.out_dir, f"overlay_timeseries_{plot_dims}dims.{args.save_format}")
    plt.savefig(out_fig, bbox_inches="tight", pad_inches=0.03, dpi=200 if args.save_format == "png" else None)
    plt.close(fig)

    print(f"[OK] saved figure: {out_fig}")
    print(f"[OK] saved equations: {unified_path}")


if __name__ == "__main__":
    main()